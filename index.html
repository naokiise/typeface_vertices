<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Inter â€” Vertices</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #000;
      color: #fff;
      font-family: system-ui, sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      overflow-x: hidden;
    }
    canvas {
      display: block;
      margin-top: 32px;
      cursor: text;
      outline: none;
    }
    #controls {
      margin-top: 24px;
      display: flex;
      align-items: center;
      gap: 24px;
      margin-bottom: 32px;
    }
    #speed-control {
      display: flex;
      align-items: center;
      gap: 12px;
    }
    #speed-control label {
      font-size: 11px;
      opacity: 0.4;
      text-transform: uppercase;
      letter-spacing: 0.1em;
    }
    #speed-control input[type="range"] {
      -webkit-appearance: none;
      appearance: none;
      width: 180px;
      height: 2px;
      background: rgba(255,255,255,0.2);
      border-radius: 1px;
      outline: none;
    }
    #speed-control input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background: #fff;
      cursor: pointer;
    }
    #speed-val {
      font-size: 11px;
      opacity: 0.4;
      min-width: 36px;
      text-align: right;
    }
    button {
      background: transparent;
      border: 1px solid rgba(255,255,255,0.25);
      color: rgba(255,255,255,0.5);
      padding: 5px 14px;
      font-size: 11px;
      border-radius: 4px;
      cursor: pointer;
      text-transform: uppercase;
      letter-spacing: 0.1em;
      transition: border-color 0.2s, color 0.2s;
    }
    button:hover {
      border-color: rgba(255,255,255,0.5);
      color: rgba(255,255,255,0.8);
    }
    button.active {
      border-color: rgba(255,255,255,0.6);
      color: #fff;
    }
  </style>
</head>
<body>
  <canvas id="canvas" tabindex="0"></canvas>
  <div id="controls">
    <div id="speed-control">
      <label>Speed</label>
      <input type="range" id="speedSlider" min="1" max="100" value="30" />
      <span id="speed-val">30</span>
    </div>
    <div id="speed-control">
      <label>Kerning</label>
      <input type="range" id="kerningSlider" min="-50" max="200" value="0" />
      <span id="kerning-val">0</span>
    </div>
    <button id="fillToggle">Fill: OFF</button>
    <button id="kerningToggle" class="active">Kerning: ON</button>
    <button id="sizeToggle" class="active">Size: ON</button>
    <button id="fadeToggle" class="active">Fade: ON</button>
    <button id="soundToggle" class="active">Sound: ON</button>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/opentype.js@1.3.4/dist/opentype.min.js"></script>
  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const speedSlider = document.getElementById('speedSlider');
    const speedVal = document.getElementById('speed-val');
    const fillToggle = document.getElementById('fillToggle');
    const kerningToggle = document.getElementById('kerningToggle');
    const sizeToggle = document.getElementById('sizeToggle');
    const kerningSlider = document.getElementById('kerningSlider');
    const kerningVal = document.getElementById('kerning-val');
    const fadeToggle = document.getElementById('fadeToggle');
    const soundToggle = document.getElementById('soundToggle');

    let showFill = false;
    let kerningEnabled = true;
    let sizeEnabled = true;
    let fadeEnabled = true;
    let soundEnabled = true;
    const FADE_DURATION = 3000;

    fillToggle.addEventListener('click', () => {
      showFill = !showFill;
      fillToggle.textContent = showFill ? 'Fill: ON' : 'Fill: OFF';
      fillToggle.classList.toggle('active', showFill);
      canvas.focus();
      scheduleFrame();
    });

    kerningToggle.addEventListener('click', () => {
      kerningEnabled = !kerningEnabled;
      kerningToggle.textContent = kerningEnabled ? 'Kerning: ON' : 'Kerning: OFF';
      kerningToggle.classList.toggle('active', kerningEnabled);
      canvas.focus();
      scheduleFrame();
    });

    sizeToggle.addEventListener('click', () => {
      sizeEnabled = !sizeEnabled;
      sizeToggle.textContent = sizeEnabled ? 'Size: ON' : 'Size: OFF';
      sizeToggle.classList.toggle('active', sizeEnabled);
      canvas.focus();
      scheduleFrame();
    });

    fadeToggle.addEventListener('click', () => {
      fadeEnabled = !fadeEnabled;
      fadeToggle.textContent = fadeEnabled ? 'Fade: ON' : 'Fade: OFF';
      fadeToggle.classList.toggle('active', fadeEnabled);
      canvas.focus();
      scheduleFrame();
    });

    soundToggle.addEventListener('click', () => {
      soundEnabled = !soundEnabled;
      soundToggle.textContent = soundEnabled ? 'Sound: ON' : 'Sound: OFF';
      soundToggle.classList.toggle('active', soundEnabled);
      canvas.focus();
    });

    const phonetics = {
      'a': 'ay', 'b': 'bee', 'c': 'see', 'd': 'dee', 'e': 'ee',
      'f': 'eff', 'g': 'jee', 'h': 'aitch', 'i': 'eye', 'j': 'jay',
      'k': 'kay', 'l': 'ell', 'm': 'em', 'n': 'en', 'o': 'oh',
      'p': 'pee', 'q': 'cue', 'r': 'are', 's': 'ess', 't': 'tee',
      'u': 'you', 'v': 'vee', 'w': 'double you', 'x': 'ex', 'y': 'why',
      'z': 'zed',
      '0': 'zero', '1': 'one', '2': 'two', '3': 'three', '4': 'four',
      '5': 'five', '6': 'six', '7': 'seven', '8': 'eight', '9': 'nine',
      ' ': 'space', '.': 'dot', ',': 'comma', '!': 'exclamation',
      '?': 'question', '@': 'at', '#': 'hash', '$': 'dollar',
      '&': 'and', '+': 'plus', '-': 'minus', '=': 'equals',
      '/': 'slash', '\\': 'backslash', ':': 'colon', ';': 'semicolon',
      '(': 'open paren', ')': 'close paren',
      '[': 'open bracket', ']': 'close bracket',
      '{': 'open brace', '}': 'close brace',
      '<': 'less than', '>': 'greater than',
      '_': 'underscore', '~': 'tilde', '`': 'backtick',
      '"': 'quote', "'": 'apostrophe', '|': 'pipe',
      '%': 'percent', '^': 'caret', '*': 'asterisk',
    };

    function pronounceChar(ch) {
      if (!soundEnabled) return;
      speechSynthesis.cancel();
      const text = phonetics[ch.toLowerCase()] || ch;
      const utt = new SpeechSynthesisUtterance(text);
      utt.lang = 'en-US';
      utt.rate = 1.1;
      utt.pitch = 1.0;
      utt.volume = 0.8;
      speechSynthesis.speak(utt);
    }

    let globalKerning = 0;

    kerningSlider.addEventListener('input', () => {
      globalKerning = parseInt(kerningSlider.value);
      kerningVal.textContent = globalKerning;
      canvas.focus();
      scheduleFrame();
    });

    const DPR = window.devicePixelRatio || 1;
    const FONT_SIZE = 260;
    const PADDING = 80;
    const ON_CURVE_RADIUS = 3.5;
    const OFF_CURVE_RADIUS = 2.5;
    const LABEL_MARGIN = 60;
    const LINE_GAP = 20;

    let font = null;
    let cursorLine = 0;
    let cursorCol = 5;
    let cursorVisible = true;
    let blinkTimer = null;
    let animFrameId = null;

    let charIdCounter = 0;
    let textData = [
      'Inter'.split('').map(c => ({ char: c, id: charIdCounter++, done: true, kerning: 0, fontSize: FONT_SIZE }))
    ];

    const animations = new Map();

    let activeKeyChar = null;
    let activeKeyDownTime = 0;
    const KERNING_RATE = 0.15;
    const MAX_KERNING = 300;
    const SIZE_RATE = 0.12;
    const MIN_FONT_SIZE = 60;
    const MAX_FONT_SIZE = 500;

    function getTextLines() {
      return textData.map(line => line.map(c => c.char).join(''));
    }

    function getSpeed() {
      return parseInt(speedSlider.value);
    }

    speedSlider.addEventListener('input', () => {
      speedVal.textContent = speedSlider.value;
      canvas.focus();
    });

    function resetBlink() {
      cursorVisible = true;
      clearInterval(blinkTimer);
      blinkTimer = setInterval(() => {
        cursorVisible = !cursorVisible;
        scheduleFrame();
      }, 530);
    }

    function scheduleFrame() {
      if (!animFrameId) {
        animFrameId = requestAnimationFrame(renderFrame);
      }
    }

    function renderFrame() {
      animFrameId = null;
      draw();

      let hasActive = activeKeyChar !== null;
      if (!hasActive) {
        for (const [id, anim] of animations) {
          if (anim.direction === -1 || anim.progress < 1) { hasActive = true; break; }
        }
      }
      if (!hasActive && (performance.now() - flashTime) < FLASH_DURATION) {
        hasActive = true;
      }
      if (!hasActive && fadeEnabled) {
        const now = performance.now();
        outer: for (const line of textData) {
          for (const c of line) {
            if (c.doneTime && (now - c.doneTime) < FADE_DURATION) { hasActive = true; break outer; }
          }
        }
      }
      if (hasActive) {
        animFrameId = requestAnimationFrame(renderFrame);
      }
    }

    async function loadFont() {
      const url = 'https://cdn.jsdelivr.net/gh/rsms/inter@v4.0/docs/font-files/InterVariable.woff2';
      try {
        font = await opentype.load(url);
      } catch (e) {
        const fallbackUrl = 'https://cdn.jsdelivr.net/gh/rsms/inter@v3.19/docs/font-files/Inter-Regular.woff2';
        try {
          font = await opentype.load(fallbackUrl);
        } catch (e2) {
          const otfUrl = 'https://cdn.jsdelivr.net/gh/rsms/inter@v3.19/docs/font-files/Inter-Regular.otf';
          font = await opentype.load(otfUrl);
        }
      }
      resetBlink();
      draw();
      canvas.focus();
    }

    function getCursorX(lineIndex, col) {
      const lineChars = textData[lineIndex] || [];
      const text = lineChars.slice(0, col).map(c => c.char).join('');
      const glyphs = font.stringToGlyphs(text);
      let x = PADDING + LABEL_MARGIN;
      for (let i = 0; i < glyphs.length; i++) {
        const cfs = (lineChars[i] && sizeEnabled) ? lineChars[i].fontSize : FONT_SIZE;
        const s = cfs / font.unitsPerEm;
        x += glyphs[i].advanceWidth * s;
        if (lineChars[i] && kerningEnabled) x += lineChars[i].kerning;
        x += globalKerning;
      }
      return x;
    }

    function getGlyphProgress(charObj) {
      if (charObj.done) return 1;
      const anim = animations.get(charObj.id);
      if (!anim) return 1;
      return anim.progress;
    }

    function updateAnimations() {
      const now = performance.now();
      const speed = getSpeed();
      const cmdPerSec = speed * 1.5;

      const toRemove = [];
      for (const [id, anim] of animations) {
        const elapsed = (now - anim.startTime) / 1000;
        const totalCmds = anim.totalCmds || 20;
        const rawProgress = (elapsed * cmdPerSec) / totalCmds;

        if (anim.direction === -1) {
          anim.progress = Math.max(0, 1 - rawProgress);
          if (anim.progress <= 0) {
            toRemove.push(id);
          }
        } else {
          if (anim.progress >= 1) continue;
          anim.progress = Math.min(1, rawProgress);
          if (anim.progress >= 1) {
            anim.progress = 1;
            for (const line of textData) {
              for (const c of line) {
                if (c.id === id) {
                  c.done = true;
                  if (!c.doneTime) c.doneTime = now;
                }
              }
            }
          }
        }
      }

      for (const id of toRemove) {
        animations.delete(id);
        for (const line of textData) {
          const idx = line.findIndex(c => c.id === id);
          if (idx !== -1) {
            line.splice(idx, 1);
            if (cursorCol > idx && cursorLine === textData.indexOf(line)) {
              cursorCol = Math.max(0, cursorCol - 1);
            }
            break;
          }
        }
      }

      if (activeKeyChar) {
        const held = now - activeKeyDownTime;
        if (kerningEnabled) {
          activeKeyChar.kerning = Math.min(MAX_KERNING, held * KERNING_RATE);
        }
        if (sizeEnabled) {
          activeKeyChar.fontSize = Math.min(MAX_FONT_SIZE, FONT_SIZE + held * SIZE_RATE);
        }
      }
    }

    function drawPartialGlyph(glyph, x, baseline, progress, charFontSize, isDeleting, fadeT, fg) {
      const fs = charFontSize || FONT_SIZE;
      const path = glyph.getPath(x, baseline, fs);
      const cmds = path.commands;
      const visibleCount = Math.ceil(progress * cmds.length);

      ctx.beginPath();
      for (let i = 0; i < visibleCount; i++) {
        const cmd = cmds[i];
        switch (cmd.type) {
          case 'M': ctx.moveTo(cmd.x, cmd.y); break;
          case 'L': ctx.lineTo(cmd.x, cmd.y); break;
          case 'Q': ctx.quadraticCurveTo(cmd.x1, cmd.y1, cmd.x, cmd.y); break;
          case 'C': ctx.bezierCurveTo(cmd.x1, cmd.y1, cmd.x2, cmd.y2, cmd.x, cmd.y); break;
          case 'Z': ctx.closePath(); break;
        }
      }
      if (isDeleting && progress < 1) {
        ctx.fillStyle = 'rgba(255, 255, 0, 1)';
        ctx.fill();
      } else if (progress < 1) {
        ctx.fillStyle = 'rgba(255, 0, 0, 1)';
        ctx.fill();
      } else if (fadeT < 1) {
        if (fadeT < 0.5) {
          const t = fadeT / 0.5;
          const r = 255;
          const g = Math.round(t * 255);
          const b = Math.round(t * 255);
          ctx.fillStyle = 'rgb(' + r + ',' + g + ',' + b + ')';
        } else {
          const t = (fadeT - 0.5) / 0.5;
          const a = 1 - t;
          ctx.fillStyle = 'rgba(255, 255, 255, ' + a + ')';
        }
        ctx.fill();
      } else if (showFill) {
        ctx.fillStyle = 'rgba(' + fg + ', 0.85)';
        ctx.fill();
      }
      ctx.strokeStyle = 'rgba(' + fg + ', 0.85)';
      ctx.lineWidth = 1.2;
      ctx.stroke();

      const points = [];
      let vertexIndex = 0;
      for (let i = 0; i < visibleCount; i++) {
        const cmd = cmds[i];
        if (cmd.type === 'Z') continue;
        if (cmd.x1 !== undefined && cmd.y1 !== undefined) {
          points.push({ x: cmd.x1, y: cmd.y1, onCurve: false, index: vertexIndex++ });
        }
        if (cmd.x2 !== undefined && cmd.y2 !== undefined) {
          points.push({ x: cmd.x2, y: cmd.y2, onCurve: false, index: vertexIndex++ });
        }
        if (cmd.x !== undefined && cmd.y !== undefined) {
          points.push({ x: cmd.x, y: cmd.y, onCurve: true, index: vertexIndex++ });
        }
      }

      let lastOnCurve = null;
      ctx.save();
      ctx.strokeStyle = 'rgba(' + fg + ', 0.15)';
      ctx.lineWidth = 0.7;
      ctx.setLineDash([3, 3]);
      for (let i = 0; i < visibleCount; i++) {
        const cmd = cmds[i];
        if (cmd.type === 'M') {
          lastOnCurve = { x: cmd.x, y: cmd.y };
        } else if (cmd.type === 'L') {
          lastOnCurve = { x: cmd.x, y: cmd.y };
        } else if (cmd.type === 'Q') {
          if (lastOnCurve) {
            ctx.beginPath();
            ctx.moveTo(lastOnCurve.x, lastOnCurve.y);
            ctx.lineTo(cmd.x1, cmd.y1);
            ctx.lineTo(cmd.x, cmd.y);
            ctx.stroke();
          }
          lastOnCurve = { x: cmd.x, y: cmd.y };
        } else if (cmd.type === 'C') {
          if (lastOnCurve) {
            ctx.beginPath();
            ctx.moveTo(lastOnCurve.x, lastOnCurve.y);
            ctx.lineTo(cmd.x1, cmd.y1);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(cmd.x, cmd.y);
            ctx.lineTo(cmd.x2, cmd.y2);
            ctx.stroke();
          }
          lastOnCurve = { x: cmd.x, y: cmd.y };
        } else if (cmd.type === 'Z') {
          lastOnCurve = null;
        }
      }
      ctx.setLineDash([]);
      ctx.restore();

      for (const pt of points) {
        if (pt.onCurve) {
          ctx.beginPath();
          ctx.arc(pt.x, pt.y, ON_CURVE_RADIUS, 0, Math.PI * 2);
          ctx.fillStyle = 'rgb(' + fg + ')';
          ctx.fill();
        } else {
          ctx.beginPath();
          ctx.arc(pt.x, pt.y, OFF_CURVE_RADIUS, 0, Math.PI * 2);
          ctx.strokeStyle = 'rgba(' + fg + ', 0.5)';
          ctx.lineWidth = 1;
          ctx.stroke();
        }
      }

      ctx.font = '9px system-ui, sans-serif';
      ctx.textBaseline = 'middle';
      for (const pt of points) {
        if (pt.onCurve) {
          ctx.fillStyle = 'rgba(' + fg + ', 0.6)';
        } else {
          ctx.fillStyle = 'rgba(' + fg + ', 0.35)';
        }
        ctx.fillText(String(pt.index), pt.x + 6, pt.y - 1);
      }
    }

    let flashTime = 0;
    const FLASH_DURATION = 150;
    let bodyFlashTimer = null;

    function triggerFlash() {
      flashTime = performance.now();
    }

    function draw() {
      if (!font) return;

      updateAnimations();

      const now = performance.now();
      const flashActive = (now - flashTime) < FLASH_DURATION;
      const flashT = flashActive ? 1 - (now - flashTime) / FLASH_DURATION : 0;
      const bgVal = Math.round(flashT * 255);
      const bg = 'rgb(' + bgVal + ',' + bgVal + ',' + bgVal + ')';
      const fgVal = 255 - bgVal;
      const fg = fgVal + ', ' + fgVal + ', ' + fgVal;

      document.body.style.backgroundColor = bg;

      const textLines = getTextLines();
      const scale = FONT_SIZE / font.unitsPerEm;
      const ascender = font.ascender * scale;
      const descender = font.descender * scale;
      const xHeight = (font.tables.os2 && font.tables.os2.sxHeight)
        ? font.tables.os2.sxHeight * scale
        : ascender * 0.52;

      const lineHeight = ascender - descender;

      let maxAdvance = 0;
      for (let li = 0; li < textData.length; li++) {
        const glyphs = font.stringToGlyphs(textLines[li]);
        let adv = 0;
        for (let i = 0; i < glyphs.length; i++) {
          const cfs = (textData[li][i] && sizeEnabled) ? textData[li][i].fontSize : FONT_SIZE;
          adv += glyphs[i].advanceWidth * (cfs / font.unitsPerEm);
          if (textData[li][i] && kerningEnabled) adv += textData[li][i].kerning;
          adv += globalKerning;
        }
        if (adv > maxAdvance) maxAdvance = adv;
      }

      let maxCharSize = FONT_SIZE;
      if (sizeEnabled) {
        for (const line of textData) {
          for (const c of line) {
            if (c.fontSize > maxCharSize) maxCharSize = c.fontSize;
          }
        }
      }
      const maxScale = maxCharSize / font.unitsPerEm;
      const maxAsc = font.ascender * maxScale;
      const maxDesc = font.descender * maxScale;
      const maxLineH = maxAsc - maxDesc;

      const minWidth = 400;
      const canvasW = Math.max(maxAdvance + PADDING * 2 + LABEL_MARGIN, minWidth);
      const canvasH = textLines.length * Math.max(lineHeight, maxLineH) + (textLines.length - 1) * LINE_GAP + PADDING * 2;

      canvas.width = canvasW * DPR;
      canvas.height = canvasH * DPR;
      canvas.style.width = canvasW + 'px';
      canvas.style.height = canvasH + 'px';
      ctx.setTransform(DPR, 0, 0, DPR, 0, 0);

      ctx.fillStyle = bg;
      ctx.fillRect(0, 0, canvasW, canvasH);

      for (let li = 0; li < textData.length; li++) {
        const lineChars = textData[li];
        const lineText = lineChars.map(c => c.char).join('');
        const glyphs = font.stringToGlyphs(lineText);
        const baseline = PADDING + ascender + li * (lineHeight + LINE_GAP);
        let x = PADDING + LABEL_MARGIN;

        const ascenderY = baseline - ascender;
        const xHeightY = baseline - xHeight;
        const descenderY = baseline - descender;

        drawMetricLines(canvasW, baseline, ascenderY, xHeightY, descenderY, li === 0, fg);

        for (let gi = 0; gi < glyphs.length; gi++) {
          const glyph = glyphs[gi];
          const charObj = lineChars[gi];
          const progress = charObj ? getGlyphProgress(charObj) : 1;
          const cfs = (charObj && sizeEnabled) ? charObj.fontSize : FONT_SIZE;
          const isDeleting = charObj && charObj.deleting;
          let fadeT = 1;
          if (fadeEnabled && charObj && charObj.doneTime && !isDeleting) {
            fadeT = Math.min(1, (performance.now() - charObj.doneTime) / FADE_DURATION);
          }

          drawPartialGlyph(glyph, x, baseline, progress, cfs, isDeleting, fadeT, fg);

          x += glyph.advanceWidth * (cfs / font.unitsPerEm);
          if (charObj && kerningEnabled) x += charObj.kerning;
          x += globalKerning;
        }
      }

      if (selectAll) {
        ctx.fillStyle = 'rgba(' + fg + ', 0.08)';
        for (let li = 0; li < textData.length; li++) {
          if (textData[li].length === 0) continue;
          const baseline = PADDING + ascender + li * (lineHeight + LINE_GAP);
          const top = baseline - ascender;
          const bottom = baseline - descender;
          const x0 = getCursorX(li, 0);
          const x1 = getCursorX(li, textData[li].length);
          ctx.fillRect(x0, top, x1 - x0, bottom - top);
        }
      }

      if (cursorVisible) {
        const curX = getCursorX(cursorLine, cursorCol);
        const baseline = PADDING + ascender + cursorLine * (lineHeight + LINE_GAP);
        const curTop = baseline - ascender;
        const curBottom = baseline - descender;

        ctx.strokeStyle = 'rgba(' + fg + ', 0.9)';
        ctx.lineWidth = 1.5;
        ctx.setLineDash([]);
        ctx.beginPath();
        ctx.moveTo(curX, curTop);
        ctx.lineTo(curX, curBottom);
        ctx.stroke();
      }
    }

    function drawMetricLines(canvasW, baseline, ascenderY, xHeightY, descenderY, showLabels, fg) {
      const lines = [
        { y: ascenderY,  label: 'Ascender' },
        { y: xHeightY,   label: 'x-height' },
        { y: baseline,    label: 'Baseline' },
        { y: descenderY,  label: 'Descender' },
      ];

      ctx.save();
      ctx.setLineDash([4, 4]);
      ctx.lineWidth = 0.6;

      for (const line of lines) {
        ctx.strokeStyle = 'rgb(' + fg + ')';
        ctx.beginPath();
        ctx.moveTo(LABEL_MARGIN + PADDING - 10, line.y);
        ctx.lineTo(canvasW - PADDING + 10, line.y);
        ctx.stroke();

        if (showLabels) {
          ctx.fillStyle = 'rgba(' + fg + ', 0.35)';
          ctx.font = '10px system-ui, sans-serif';
          ctx.textAlign = 'right';
          ctx.textBaseline = 'middle';
          ctx.fillText(line.label, LABEL_MARGIN + PADDING - 16, line.y);
        }
      }

      ctx.setLineDash([]);
      ctx.textAlign = 'left';
      ctx.restore();
    }

    function startAnimation(charObj) {
      const glyphs = font.stringToGlyphs(charObj.char);
      const g = glyphs[0];
      const path = g ? g.getPath(0, 0, FONT_SIZE) : { commands: [] };
      const totalCmds = path.commands.length || 1;

      charObj.done = false;
      animations.set(charObj.id, {
        progress: 0,
        startTime: performance.now(),
        totalCmds: totalCmds,
        direction: 1
      });
      scheduleFrame();
    }

    function startDeleteAnimation(charObj) {
      const glyphs = font.stringToGlyphs(charObj.char);
      const g = glyphs[0];
      const path = g ? g.getPath(0, 0, FONT_SIZE) : { commands: [] };
      const totalCmds = path.commands.length || 1;

      charObj.done = false;
      charObj.deleting = true;
      animations.set(charObj.id, {
        progress: 1,
        startTime: performance.now(),
        totalCmds: totalCmds,
        direction: -1
      });
      scheduleFrame();
    }

    let selectAll = false;

    function clearSelection() {
      selectAll = false;
    }

    function deleteAll() {
      for (const line of textData) {
        for (const c of line) animations.delete(c.id);
      }
      textData = [[]];
      cursorLine = 0;
      cursorCol = 0;
      selectAll = false;
    }

    canvas.addEventListener('keydown', (e) => {
      if (!font) return;
      const key = e.key;

      if (key === 'a' && (e.metaKey || e.ctrlKey)) {
        e.preventDefault();
        selectAll = true;
        resetBlink();
        scheduleFrame();
        return;
      }

      if (selectAll && (key === 'Backspace' || key === 'Delete')) {
        e.preventDefault();
        deleteAll();
        resetBlink();
        scheduleFrame();
        return;
      }

      if (selectAll && key.length === 1 && !e.ctrlKey && !e.metaKey) {
        e.preventDefault();
        if (e.repeat) return;
        deleteAll();
        const newChar = { char: key, id: charIdCounter++, done: false, kerning: 0, fontSize: FONT_SIZE };
        textData[0].push(newChar);
        cursorCol = 1;
        activeKeyChar = newChar;
        activeKeyDownTime = performance.now();
        triggerFlash();
        pronounceChar(key);
        startAnimation(newChar);
        resetBlink();
        return;
      }

      if (selectAll && key === 'Enter') {
        e.preventDefault();
        deleteAll();
        resetBlink();
        scheduleFrame();
        return;
      }

      clearSelection();

      if (key === 'Backspace') {
        e.preventDefault();
        if (cursorCol > 0) {
          const target = textData[cursorLine][cursorCol - 1];
          if (target && !target.deleting) {
            triggerFlash();
            startDeleteAnimation(target);
            cursorCol--;
          }
        } else if (cursorLine > 0) {
          const prevLen = textData[cursorLine - 1].length;
          textData[cursorLine - 1] = textData[cursorLine - 1].concat(textData[cursorLine]);
          textData.splice(cursorLine, 1);
          cursorLine--;
          cursorCol = prevLen;
        }
        resetBlink();
        scheduleFrame();
      } else if (key === 'Delete') {
        e.preventDefault();
        if (cursorCol < textData[cursorLine].length) {
          const target = textData[cursorLine][cursorCol];
          if (target && !target.deleting) {
            triggerFlash();
            startDeleteAnimation(target);
          }
        } else if (cursorLine < textData.length - 1) {
          textData[cursorLine] = textData[cursorLine].concat(textData[cursorLine + 1]);
          textData.splice(cursorLine + 1, 1);
        }
        resetBlink();
        scheduleFrame();
      } else if (key === 'Enter') {
        e.preventDefault();
        const rest = textData[cursorLine].splice(cursorCol);
        textData.splice(cursorLine + 1, 0, rest);
        cursorLine++;
        cursorCol = 0;
        resetBlink();
        scheduleFrame();
      } else if (key === 'ArrowLeft') {
        e.preventDefault();
        if (cursorCol > 0) cursorCol--;
        else if (cursorLine > 0) { cursorLine--; cursorCol = textData[cursorLine].length; }
        resetBlink(); scheduleFrame();
      } else if (key === 'ArrowRight') {
        e.preventDefault();
        if (cursorCol < textData[cursorLine].length) cursorCol++;
        else if (cursorLine < textData.length - 1) { cursorLine++; cursorCol = 0; }
        resetBlink(); scheduleFrame();
      } else if (key === 'ArrowUp') {
        e.preventDefault();
        if (cursorLine > 0) { cursorLine--; cursorCol = Math.min(cursorCol, textData[cursorLine].length); }
        resetBlink(); scheduleFrame();
      } else if (key === 'ArrowDown') {
        e.preventDefault();
        if (cursorLine < textData.length - 1) { cursorLine++; cursorCol = Math.min(cursorCol, textData[cursorLine].length); }
        resetBlink(); scheduleFrame();
      } else if (key === 'Home') {
        e.preventDefault(); cursorCol = 0; clearSelection(); resetBlink(); scheduleFrame();
      } else if (key === 'End') {
        e.preventDefault(); cursorCol = textData[cursorLine].length; clearSelection(); resetBlink(); scheduleFrame();
      } else if (key.length === 1 && !e.ctrlKey && !e.metaKey) {
        e.preventDefault();
        if (e.repeat) return;
        const newChar = { char: key, id: charIdCounter++, done: false, kerning: 0, fontSize: FONT_SIZE };
        textData[cursorLine].splice(cursorCol, 0, newChar);
        cursorCol++;
        activeKeyChar = newChar;
        activeKeyDownTime = performance.now();
        triggerFlash();
        pronounceChar(key);
        startAnimation(newChar);
        resetBlink();
      }
    });

    canvas.addEventListener('keyup', (e) => {
      if (activeKeyChar && e.key === activeKeyChar.char) {
        activeKeyChar = null;
        scheduleFrame();
      }
    });

    canvas.addEventListener('click', (e) => {
      canvas.focus();
      if (!font) return;

      const rect = canvas.getBoundingClientRect();
      const clickX = e.clientX - rect.left;
      const clickY = e.clientY - rect.top;

      const scale = FONT_SIZE / font.unitsPerEm;
      const ascender = font.ascender * scale;
      const descender = font.descender * scale;
      const lineHeight = ascender - descender;

      let bestLine = 0;
      let bestDist = Infinity;
      for (let li = 0; li < textData.length; li++) {
        const baseline = PADDING + ascender + li * (lineHeight + LINE_GAP);
        const midY = baseline - ascender / 2;
        const dist = Math.abs(clickY - midY);
        if (dist < bestDist) { bestDist = dist; bestLine = li; }
      }
      cursorLine = bestLine;

      let bestCol = 0;
      let bestColDist = Infinity;
      for (let c = 0; c <= textData[cursorLine].length; c++) {
        const cx = getCursorX(cursorLine, c);
        const dist = Math.abs(clickX - cx);
        if (dist < bestColDist) { bestColDist = dist; bestCol = c; }
      }
      cursorCol = bestCol;
      clearSelection();
      resetBlink(); scheduleFrame();
    });

    window.addEventListener('resize', () => scheduleFrame());
    loadFont();
  </script>
</body>
</html>
